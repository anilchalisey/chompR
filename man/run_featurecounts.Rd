% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_featurecounts.R
\name{run_featurecounts}
\alias{run_featurecounts}
\title{Count reads in bam files using featureCounts}
\usage{
run_featurecounts(featurecounts = "featureCounts",
  annotationFile = NULL, requireBothEndsMapped = TRUE,
  excludeChimeric = TRUE, pairedEnd = TRUE, fragmentLength = c(30,
  800), countMultiMapping = FALSE, multiFeatureReads = FALSE,
  minQual = 0, stranded = 0, threads = NULL, ignoreDup = FALSE,
  outname = NULL, alignments = NULL, quiet = TRUE)
}
\arguments{
\item{featurecounts}{character string specifying path to featureCounts. [DEFAULT = "featurecounts"]}

\item{annotationFile}{character string, specifying path to region file in SAF format.}

\item{requireBothEndsMapped}{logical, if TRUE, only fragments that have both
ends successfully aligned will be considered for summarization. This option
should be used together with pairedEnd = TRUE. [DEFAULT = TRUE]}

\item{excludeChimeric}{logical, if TRUE, the chimeric fragments (those
fragments that have their two ends aligned to different chromosomes) will
NOT be counted. This option should be used together with pairedEnd = TRUE. [DEFAULT = TRUE]}

\item{pairedEnd}{logical, if TRUE,  fragments (or templates) will be counted
instead of reads. This option is only applicable for paired-end reads. [DEFAULT = TRUE]}

\item{fragmentLength}{vector of two integers specifying the minimum and
maximum fragment/template lengths.  Must be used together with pairedEnd = TRUE.
[DEFAULT = c(50, 600)].}

\item{countMultiMapping}{logical, if TRUE then multi-mapping reads/fragments will be
counted. [DEFAULT = FALSE]}

\item{multiFeatureReads}{logical, if TRUE then reads/fragments overlapping with more than one
meta-feature/feature will be counted more than once. Note that when
performing meta-feature level summarization, a read (or fragment) will
still be counted once if it overlaps with multiple features within the same
meta-feature (as long as it does not overlap with other metafeatures). [DEFAULT = FALSE]}

\item{minQual}{integer, the minimum mapping quality score a read must satisfy in
order to be counted. For paired-end reads, at least one end should satisfy
this criteria. [DEFAULT = 0]}

\item{stranded}{Indicate if strand-specific read counting should be
performed.  Acceptable values: 0 (unstranded), 1 (stranded) and 2
(reversely stranded). For paired-end reads, strand of the
first read is taken as the strand of the whole fragment. [DEFAULT = 0]}

\item{threads}{an integer value indicating the number of workers to be used. If NULL then one less than the
maximum number of cores will be used. [DEFAULT = NULL].}

\item{ignoreDup}{logical, if TRUE then reads that were marked as duplicates will
be ignored.  In paired end data, the entire read pair will be ignored if at
least one end is found to be a duplicate read. [DEFAULT = FALSE]}

\item{outname}{Character string.  Name of the output file. The output file
contains the number of reads assigned to each meta-feature or feature.}

\item{alignments}{character vector specifying path to alignment files. [DEFAULT = NULL]}

\item{quiet}{logical, if \code{TRUE} then summary information not displayed}
}
\value{
Tab-delimited file containing the number of reads assigned to each
meta-feature or feature and a matrix with the same.
}
\description{
Function to count reads mapping to user-provided regions.
}
\examples{
\dontrun{
alignments <- list.files(path = "bam_files", pattern = "*.bam$")
threads <- parallel::detectCores() - 1
counts <- count_reads(featurecounts = "featureCounts", threads = threads,
                      alignments = alignments)
}
}
